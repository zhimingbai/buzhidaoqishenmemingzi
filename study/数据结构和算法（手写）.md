# 数据结构和算法

## 第一章，绪论

### 1.2基本概念和术语

数据（data）在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称。

数据元素是数据的最基本单位。

一个数据元素可以由多个数据域组成，数据域是数据的不可分割的最小单位（有独立含义）。

数据对象是性质相同的数据元素的集合。

数据结构是相互之间存在一种或多种特定关系的数据元素的集合

常见的数据结构有：

1. 集合结构
2. 线性结构
3. 树形结构
4. 图装结构（网状结构）

一般情况下，我们称线性结构、树形结构、图装结构为逻辑结构，逻辑结构一般是用来描述数据元素之间的逻辑关系的。

数据结构在计算机当中表示数据的物理结构的一般称为存储结构，其中存储结构又分为两种，顺序存储结构和链式存储结构。

### 1.4算法和算法分析

评价算法的标准：一般来说评价一个算法的好坏就是看它的时间和空间，因为空间现在的内存都很大，考虑的比较少，我们主要考虑算法的时间复杂度怎样进行度量。

算法效率：用依据该算法编制的程序在计算机上执行所消耗的时间来度量。通常有两种方法：事后统计和事前分析估计，但一般情况下我们使用`事前分析估计` 

`时间复杂度`：可以用算法中基本操作重复执行的次数作为算法的时间量度。若将基本操作重复执行的次数作为问题规模n的某个函数f(n),算法的时间量度（即时间复杂度）记作：
$$
T(n) = O(f(n))
$$
时间复杂度的基本分析方法：

- 找出语句频度最大的那条语句作为基本语句
- 计算基本语句的频度得到问题规模n的某个函数f(n)
- 取其数量级用符号“O”表示

相关的统计方法：

忽略所有低次幂项和最高次幂系数，体现出增长率的含义，只统计最高次方。

`空间复杂度`：算法所需存储空间的度量
$$
S(n)=O(f(n)) 
$$
其中n为问题的规模(或大小)。

算法要占据的空间：

- 算法本身要占据的空间，输入/输出，指令，常数，变量等
- 算法要使用的辅助空间

## 第二章，线性表

线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。

同时，线性表本身属于，逻辑结构，因此会有两种存储结构：顺序结构和链式结构。因此能够产生两种表，顺序表和链式表

线性表一般需要包含以下功能：

* **初始化线性表：**将一个线性表进行初始化，得到一个全新的线性表。
* **获取指定位置上的元素：**直接获取线性表指定位置`i`上的元素。
* **获取元素的位置：**获取某个元素在线性表上的位置`i`。
* **插入元素：**在指定位置`i`上插入一个元素。
* **删除元素：**删除指定位置`i`上的一个元素。
* **获取长度：**返回线性表的长度。

实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。

### 顺序表

底层通过数组实现，一般是动态数组

示例代码：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct List{
    //array是一个指向整型数组的指针，用于存储顺序表的元素。
    int *array;
    //capacity表示顺序表当前分配的内存容量（即array所指向的数组的大小）。
    int capacity;
    //size表示当前顺序表中已有元素的个数。
    int size;
} arrayList;

int initList(arrayList *list){
    //初始化list->capacity为10，表示array所指向的数组的大小为10，也就是说最多能存10个数据
    list->capacity = 10;
    //让array所指向的数组初始化，数组可以简单认为是指针+内存
    /*
    	malloc()函数是一个动态分配的函数,可以分配一定长度的内存给指针
    */
    list->array = (int *) malloc(sizeof(int)*list->capacity);
    //如果内存分配失败的话，再给capacity重新赋值为0
    if(list->array==NULL){
        list->capacity = 0;
        return 0;
    }
    //成功的话，接着初始化list->size
    list->size = 0;
    return 1;
}
//insertList函数用于向顺序表中插入元素。
//传入的参数包括顺序表指针list、要插入的数据data和插入的位置index。
void insertList(arrayList *list,int data,int index){
    //判断是否符合插入标准
    if (index < 1 || index > list->size + 1) {
        printf("插入位置超出范围\n");
        return;
    }
    //判断是否需要把顺序表进行扩容
    if(list->size>=list->capacity){
        //让新的内存变为原来的2倍
        int newCapacity=list->capacity*2;
        //realloc()函数实现这一操作
        //realoc()函数，可以实现重新分配n个空间长度的内存
        //并且能够把原本指向的空间复制到新空间
        int *newArray=realloc(list->array,newCapacity* sizeof(int));
        //判断内存是否扩容失败
        if(newArray==NULL){
            printf("内存扩容失败\n");
            return;
        }
        // 更新顺序表的 capacity 和 array 指针
        list->capacity = newCapacity;
        list->array = newArray;
    }
    //在插入元素之前，先将插入位置之后的所有元素依次向后移动一位，为新元素腾出位置。
    /*
     *简单阐述一下，工作原理
     * 首先list->array现在是一个数组，所以要按照数组的索引来
     * 为了能够让在数组内index - 1的位置上插入一个数组，需要让这个位置及其之后位置上的数据一次向后移动一位
     * 因此我们需要从后往前遍历，一次向后退一位
     */
    for (int i = list->size - 1; i >= index - 1; i--) {
        list->array[i + 1] = list->array[i];
    }
    //然后将新元素data插入到指定位置index处
    list->array[index-1]=data;
    //最后，更新顺序表的size，表示元素个数增加了一个。
    list->size++;
}
void deleteList(arrayList *list, int index){
    //list就是待操作的表，index是要删除的元素位序
    if(index<1||index>list->size){
        printf("删除位置超出范围\n");
        return;
    }
    //先将删除位置之后的所有元素依次向前移动一位，这次是从前往后遍历，为新元素腾出位置。
    for (int i = index; i < list->size - 1; i++) {
        list->array[i] = list->array[i + 1];
    }
    //最后，更新顺序表的size，表示元素个数减少了一个。
    list->size--;
}
//获取元素
int getList(arrayList *list,int index){
    if(index<1||index>list->size){
        printf("超出范围\n");
        return 0;
    }
    int data=list->array[index];
    return data;
}
//查找元素的位置
int findList(arrayList *list,int data){
    for (int i = 0; i < list->size-1; ++i) {
        if(data==list->array[i]){
            return i+1;
        }
    }
    return 0;
}
//printList函数用于打印顺序表中的所有元素。
void printList(arrayList *list){
    //遍历循环输出
    for (int i = 0; i < list->size; ++i) {
        printf("%d ",list->array[i]);
    }
    printf("\n");
}

int main(void) {
    struct List list;
    if(initList(&list)){
        for (int i = 1; i < 30; ++i)
            insertList(&list, i*10, i);
        deleteList(&list,10);
        deleteList(&list,20);
        deleteList(&list,13);
        deleteList(&list,24);
        if(getList(&list,10)!=0){
            printf("%d\n",getList(&list,10));
        }else{
            printf("索引不存在\n");
        }
        if(findList(&list,10)!=0){
            printf("%d\n",findList(&list,160));
        } else{
            printf("数据不存在\n");
        }
        printList(&list);
    } else{
        printf("顺序表初始化失败，无法启动程序！");
    }
    return 0;
}
```

运行结果：

```c
120
14
10 20 30 40 50 60 70 80 90 100 120 130 140 160 170 180 190 200 210 230 240 250 260 270 290
```

在c++环境下编写的代码：

```C
#include <stdio.h>
#include <stdlib.h>

#define Ture 1
#define False 0
#define state int


//创建数据类型的节点
typedef struct {
	char name[20];
	int id;
	int age;
} student;

//创建节点
typedef struct {
	student *stu;
	int length;
	int listSize;
} List;

//初始化顺序表
state initList(List &list) {
	list.listSize = 10;
	list.length = 0;
	//动态内存分配空间
	list.stu = (student *) malloc(list.listSize * sizeof(student));
	//如果初始化失败
	if (list.stu == NULL) {
		printf("内存初始化失败,请检查内存\n");
		list.listSize = 0;
		return False;
	}
	return Ture;
}

//插入数据
state insertList(List &list, student newStu, int index) {
	//判断插入是否符合标准
	if (index < 1 || index > list.length + 1) {
		printf("该位置插入是非法的，请重新插入\n");
		return False;
	}
	//判断是否需要自动扩容
	if (list.length>=list.listSize){
		int newListSize= list.listSize + 10;
		student *student1;
		student1=(student *)realloc(list.stu,newListSize* sizeof(student));
		//如果自动扩容失败
		if (student1==NULL){
			printf("自动扩容失败，请检查\n");
			return False;
		}
		list.stu=student1;
		list.listSize=newListSize;
	}
	//向后遍历一位
	for (int i = list.length-1; i >= index-1 ; i--) {
		list.stu[i+1] = list.stu[i];
	}
	list.stu[index-1] = newStu;
	list.length++;
	return Ture;
}

//遍历顺序表
void printList(List &list) {
	printf("开始遍历\n");
	for (int i = 0; i < list.length; i++) {
		printf("第%d行：学号：%d，姓名：%s，年龄：%d\n",
			(i+1),list.stu[i].id, list.stu[i].name, list.stu[i].age);
	}
	printf("结束遍历\n");
}

//通过学号删除对应的学生信息
state deleteList(List &list, int id) {
	int index = -1;
	for (int i = 0; i < list.length; i++) {
		if (list.stu[i].id == id) {
			index = i+1;
			break;
		}
	}
	if (index == -1) {
		printf("该学号不存在\n");
		return False;
	}
	for (int i = index-1; i < list.length-1; i++) {
		list.stu[i] = list.stu[i+1];
	}
	list.length--;
	return Ture;
}

//通过索引删除对应的学生信息
state deleteListByIndex(List &list, int index) {
	if (index < 1 || index > list.length) {
		printf("该位置删除是非法的，请重新删除\n");
		return False;
	}
	for (int i = index-1; i < list.length-1; i++) {
		list.stu[i] = list.stu[i+1];
	}
	list.length--;
	return Ture;
}

//通过学号获取学生信息
state getStudent(List &list, int id,student &student) {
	int index = -1;
	for (int i = 0; i < list.length; i++) {
		if (list.stu[i].id == id) {
			index = i+1;
			break;
		}
	}
	if (index == -1) {
		printf("该学号不存在\n");
		return False;
	}
	student = list.stu[index-1];
	return Ture;
}

//通过索引找到学生的信息
state getStudentByIndex(List &list, int index,student &student) {
	if (index < 1 || index > list.length) {
		printf("该位置获取是非法的，请重新获取\n");
		return False;
	}
	student = list.stu[index-1];
	return Ture;
}

//通过学号找到当前学生的索引
state getStudentIndex(List &list, int id,int &index) {
	index=-1;
	for (int i = 0; i < list.length; i++) {
		if (list.stu[i].id == id) {
			index = i+1;
			break;
		}
	}
	if (index == -1) {
		printf("该学号不存在\n");
		return False;
	}
	return Ture;
}

int main() {
	student student;
	List list;
	int index=0;
	int judge=initList(list);
	if (judge==False){
		return 0;
	}
	student={"朱嘎蛋",41,20};
	judge=insertList(list,student,1);
	if (judge==False){
		return 0;
	}
	student={"刘大侠",3,19};
	judge=insertList(list,student,2);
	if (judge==False){
		return 0;
	}
	student={"白芷茗",55,19};
	judge=insertList(list,student,2);
	if (judge==False){
		return 0;
	}
	printList(list);
	while (Ture){
		printf("输入0表示退出程序\n"
			"输入1表示插入学生信息\n"
			"输入2表示遍历学生信息\n"
			"输入3表示通过学号删除对应的学生信息\n"
			"输入4表示通过索引删除对应的学生信息\n"
			"输入5表示通过学号获取学生信息\n"
			"输入6表示通过索引找到学生的信息\n"
			"输入7表示通过学号找到当前学生的索引\n");
		int choice=0;
		int id=0;
		scanf("%d",&choice);
		switch (choice){
		case 0:
			return 0;
			break;
		case 1:
			printf("输入学号，姓名，年龄以及索引\n");
			scanf("%d%s%d%d",&student.id,student.name,&student.age,&index);
			judge=insertList(list,student,index);
			if (judge==False){
				break;
			}
			printList(list);
			break;
		case 2:
			printList(list);
			break;
		case 3:
			printf("输入学号\n");
			scanf("%d",&id);
			judge=deleteList(list,id);
			if (judge==False){
				break;
			}
			printf("已删除，请遍历查看是否已经成功删除\n");
			break;
		case 4:
			printf("输入索引\n");
			scanf("%d",&index);
			judge=deleteListByIndex(list,index);
			if (judge==False){
				break;
			}
			printf("已删除，请遍历查看是否已经成功删除\n");
			break;
		case 5:
			printf("输入学号\n");
			scanf("%d",&id);
			judge=getStudent(list,id,student);
			if (judge==False){
				break;
			}
			printf("学号：%d，姓名：%s，年龄：%d\n",
				student.id,student.name,student.age);
			break;
		case 6:
			printf("输入索引\n");
			scanf("%d",&index);
			judge=getStudentByIndex(list,index,student);
			if (judge==False){
				break;
			}
			printf("学号：%d，姓名：%s，年龄：%d\n",
				student.id,student.name,student.age);
			break;
		case 7:
			printf("学号\n");
			scanf("%d",&id);
			judge=getStudentIndex(list,id,index);
			if (judge==False){
				break;
			}
			printf("当前学生的索引为%d\n",index);
			break;
		default:
			printf("输入错误\n");
			break;
		}
	}
	return 0;
}
```



### 单链表

线性表：1、有限的序列。2、列表中的每一个元素都有唯一的前驱和后继，除了开头和结尾两个节点。

线性表目前在计算机当中的两种实现，第一种为顺序表：分配一块连续的内存去存放这些元素，例如编程语言中的数组。第二种为链表：内存是不连续的，元素会各自分配一块内存，内存与内存之间通过指针进行相连。

单链表的基本组成为节点，每个节点由两部分组成：数据域和指针域，数据域用于存放是数据，指针域用于指向下一个节点。

单链表的基本操作：

- 增加：
  - 头插法：放在开头，让我们所增加的那个元素指向原来的第一个元素。
  - 尾插法：放在结尾，让我们原本最后的那个元素指向我们增加的那个元素，同时新的节点指向NULL
- 删除：假设有`1->2->3` 这样的一个单链表，删除 `2` 节点，只需要把 `1` 节点的指针指向`3` ，并且把`2`节点的内存空间`free`掉即可。

一般情况下，单链表还会有有一个头节点，头节点本身结构与一般的链表元素一模一样，只是头节点中的data里面存放的一般是链表的元素个数。



c语言的简单实例：

```c
#include <stdio.h>
#include <stdlib.h>

//定义节点数据
struct Node {
    //数据域
    int data;
    //指针域
    struct Node *next;
};

//创建一个空的单链表，并返回指向该单链表头结点的指针。
struct Node *createList() {
    //headNode就成为了结构体变量
    struct Node *headNode = (struct Node *) malloc(sizeof(struct Node));
    //变量的初始化
    headNode->data = 0;
    headNode->next = NULL;
    return headNode;
}

//创建节点
struct Node *createNode(int data) {
    //创建结构体变量
    struct Node *newNode = (struct Node *) malloc(sizeof(struct Node));
    //新节点的数值域等于传进的数值
    newNode->data = data;
    //新节点的指针域指向NULL
    newNode->next = NULL;
    //返回新节点
    return newNode;
}

//其作用是打印输出给定单链表中所有节点的数据。
//它接受一个指向struct Node类型的指针作为参数，命名为headNode。
//这个参数是指向单链表头节点的指针，通过这个头节点，我们可以遍历整个链表。
void printList(struct Node *headNode) {
    //初始化pMove为headNode的下一个节点，即跳过头节点，指向链表的第一个实际节点（如果有的话）。
    struct Node *pMove = headNode->next;
    //这是一个while循环，它会持续执行直到pMove指向了链表的最后一个节点之后的NULL。
    //在循环中，我们遍历整个链表，每次迭代移动到下一个节点。
    while (pMove != NULL) {
        //在循环内部，我们使用printf函数打印输出当前节点的数据域值。
        //pMove->data表示当前节点的数据。
        printf("%d ", pMove->data);
        pMove = pMove->next;
    }
}

//头插法：插入节点，参数：插入哪个链表，插入节点的数据是多少
void insertNodeByHead(struct Node *headNode, int data) {
    //创建插入的节点
    struct Node *newNode = createNode(data);
    //插入节点
    newNode->next = headNode->next;
    headNode->next = newNode;
}
//尾插法：
void tailInsertion(struct Node *headNode,int data) {
    //创建插入节点newNode
    struct Node *newNode = createNode(data);
    //创建一个过渡节点,方便我们找到链表最后一个节点，并让过渡节点等于头节点
    struct Node *lastNode = headNode;
    //一直循环，让lastNode变成该链表的最后一个节点
    while (lastNode->next != NULL){
        lastNode=lastNode->next;
    }
    //然后让过渡节点的next指向newNode
    lastNode->next=newNode;
}
//删除指定位置节点
void deletesTheSpecifiedLocationNode(struct Node *headNode, int deleteData) {
    //在函数内部，定义了一个指向struct Node类型的指针deleteNode，用于遍历单链表。
    //初始化deleteNode为headNode的下一个节点，即跳过头节点，指向链表的第一个实际节点（如果有的话）。
    struct Node *deleteNode = headNode->next;
    //还定义了另一个指向struct Node类型的指针deleteNodeFront，
    // 用于记录当前deleteNode的前一个节点，方便删除操作。
    //初始化deleteNodeFront为headNode，因为一开始并没有前一个节点，
    // 而头节点在这里充当了一个虚拟的前一个节点。
    struct Node *deleteNodeFront = headNode;
    //这是一个条件判断语句，用于检查链表是否为空。
    //如果链表为空（即没有实际节点），则打印输出一条消息表示无法删除链表。
    if (deleteNode == NULL) {
        printf("无法删除链表，链表为空\n");
        return;
    } else {
        //这是一个循环，用于在链表中找到与deleteData相等的节点。
        //在循环中，我们遍历链表，直到找到目标节点的数据域与deleteData相等，
        // 或者遍历到链表末尾（deleteNode为NULL）。
        while (deleteNode->data != deleteData) {
            //让前一个deleteNodeFront与deleteNode相等
            deleteNodeFront = deleteNode;
            //让deleteNode往后退一位
            deleteNode = deleteNodeFront->next;
            if (deleteNode == NULL) {
                printf("没有找到有关节点，无法删除\n");
                return;
            }
        }
        //当找到目标节点后，我们将目标节点的前一个节点的next指针指向目标节点的下一个节点，
        // 从而跳过目标节点，将其从链表中删除。
        deleteNodeFront->next = deleteNode->next;
        //最后，我们释放掉目标节点的内存，防止内存泄漏。
        free(deleteNode);
    }
}

int main() {
    struct Node *list = createList();
    insertNodeByHead(list, 1);
    insertNodeByHead(list, 2);
    insertNodeByHead(list, 3);
    insertNodeByHead(list, 4);
    insertNodeByHead(list, 5);
    insertNodeByHead(list, 6);
    printList(list);
    printf("\n");
    deletesTheSpecifiedLocationNode(list,3);
    deletesTheSpecifiedLocationNode(list,1);
    printList(list);
    printf("\n");
    tailInsertion(list,10);
    tailInsertion(list,11);
    tailInsertion(list,12);
    tailInsertion(list,13);
    printList(list);
    printf("\n");
    return 0;
}
```

运行结果：

```c
6 5 4 3 2 1
6 5 4 2
6 5 4 2 10 11 12 13
```

就目前我理解的来看，基于这个程序，list 其本质就只是一个头节点，然后头节点的指针域指向了第一个节点，第一个节点的指针域又指向了第二个节点，等等以此类推，指到最后一个节点的指针域指向`NULL`时，表示链表结束。

### 单循环链表

单循环链表其实和单链表很像，只不过单循环链表的最后一个节点的指针域指向第一个节点。

假设我们有一个链表，里面有两个节点（1，2）和一个头节点，单循环链表其实就是头节点->1节点->2节点->头节点->1节点->2节点->......，从某种层面来说进入了一个`死循环`。因此当我们的链表只有头节点或是只有一个节点的时候，也需要进入死循环，那么就需要我们在创建节点的时候，需要让`newNode->next = newNode;` 只有这样，才能保证我们最后写出的链表是一个死循环。

c语言的简单实例：

```c
#include <stdio.h>
#include <stdlib.h>

//本链表为单循环链表
//定义节点数据
struct Node {
    int data;
    struct Node *next;
};

//创建链表
//为了我们的链表最后进入死循环，
// 因此我们创建的每一个节点时都需要newNode->next = newNode;
struct Node *createList() {
    struct Node *headNode = (struct Node *) malloc(sizeof(struct Node));
    headNode->data = 0;
    headNode->next = headNode;
    return headNode;
}

//创建节点
//为了我们的链表最后进入死循环，
// 因此我们创建的每一个节点时都需要newNode->next = newNode;
struct Node *createNode(int data) {
    struct Node *newNode = (struct Node *) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = newNode;
    return newNode;
}

//头插法
void headInsert(struct Node *headNode, int data) {
    struct Node *newNode = createNode(data);
    //头插法的基本格式保持不变
    newNode->next = headNode->next;
    headNode->next = newNode;
}

//尾插法
void tailInsertion(struct Node *headNode, int data) {
    //创建插入节点newNode
    struct Node *newNode = createNode(data);
    //创建一个过渡节点,方便我们找到链表最后一个节点，并让过渡节点等于头节点
    struct Node *lastNode = headNode;
    //一直循环，让lastNode变成该链表的最后一个节点
    //切记,这里跟循环跳出条件和printList()里面的是不一样的
    while (lastNode->next != headNode) {
        lastNode = lastNode->next;
    }
    //然后让过渡节点的next指向newNode
    lastNode->next = newNode;
    //让newNode的next指向headNode，一次来保证死循环。
    newNode->next = headNode;
}

//删除指定位置节点
void deletesTheSpecifiedLocationNode(struct Node *headNode, int deleteData) {
    //在函数内部，定义了一个指向struct Node类型的指针deleteNode，用于遍历单链表。
    //初始化deleteNode为headNode的下一个节点，即跳过头节点，指向链表的第一个实际节点（如果有的话）。
    struct Node *deleteNode = headNode->next;
    //还定义了另一个指向struct Node类型的指针deleteNodeFront，
    // 用于记录当前deleteNode的前一个节点，方便删除操作。
    //初始化deleteNodeFront为headNode，因为一开始并没有前一个节点，
    // 而头节点在这里充当了一个虚拟的前一个节点。
    struct Node *deleteNodeFront = headNode;
    //这是一个条件判断语句，用于检查链表是否为空。
    //如果链表为空（即没有实际节点），则打印输出一条消息表示无法删除链表。并且直接跳出函数
    if (deleteNode == headNode) {
        printf("无法删除链表，链表为空\n");
        return;
    } else {
        while (deleteNode->data != deleteData) {
            //让前一个deleteNodeFront与deleteNode相等
            deleteNodeFront = deleteNode;
            //让deleteNode往后退一位
            deleteNode = deleteNode->next;
            //在没有找到相关节点的情况下，可以直接return;来直接跳出循环
            if (deleteNode == headNode) {
                printf("没有找到有关节点，无法删除\n");
                return;
            }
        }
        deleteNodeFront->next = deleteNode->next;
        free(deleteNode);
    }
}

//遍历打印输出链表
void printList(struct Node *headNode) {
    struct Node *moveNode = headNode->next;
    /*
     * 因为我们目前的链表是一个死循环，所以就不能让moveNode != NULL
     * 其实我们就只需要循环一次链表，那么第一次循环结束的收跳出循环即可
     * 那么moveNode == headNode的时候，我们的链表就已经循环了一次
     * 那么moveNode != headNode不成立的时候，就可以跳出循环了。
     */
    while (moveNode != headNode) {
        printf("%d->", moveNode->data);
        moveNode = moveNode->next;
    }
    printf("headNode\n");
}

int main(void) {
    struct Node *list1 = createList();
    headInsert(list1, 1);
    headInsert(list1, 2);
    headInsert(list1, 3);
    headInsert(list1, 4);
    headInsert(list1, 5);
    headInsert(list1, 6);
    printList(list1);
    deletesTheSpecifiedLocationNode(list1,4);
    deletesTheSpecifiedLocationNode(list1,6);
    deletesTheSpecifiedLocationNode(list1,7);
    printList(list1);
    struct Node *list2 = createList();
    tailInsertion(list2, 1);
    tailInsertion(list2, 2);
    tailInsertion(list2, 3);
    tailInsertion(list2, 4);
    tailInsertion(list2, 5);
    tailInsertion(list2, 6);
    printList(list2);
    deletesTheSpecifiedLocationNode(list2,4);
    deletesTheSpecifiedLocationNode(list2,6);
    deletesTheSpecifiedLocationNode(list2,7);
    printList(list2);
    return 0;
}
```

运行结果：

```c
6->5->4->3->2->1->headNode
没有找到有关节点，无法删除
5->3->2->1->headNode
1->2->3->4->5->6->headNode
没有找到有关节点，无法删除
1->2->3->5->headNode
```

单循环链表与单链表类似，但其实内部也有很大不同，具体的我均在代码当中以注释展示出来了。

### 双链表

双链表因为本身的特性，所以跟单链表的差别不是很大，在其每个当中节点都有一个前指针域和一个后指针域，其中前指针域指向前面的节点，后指针域的作用与单链表中的指针的作用相同。


下面是源代码：

```c
//双链表
#include <stdio.h>
#include <stdlib.h>

#define TURE 1
#define FALSE 0

/*
 * 双链表因为本身的特性原因，因而会有连个指针域
 * 其中pre指针是指向上一个节点的指针，next指向下一个节点的指针
 */
//创建节点
typedef struct Node {
    int data;
    struct Node *pre;
    struct Node *next;
} Node, LinKList;

//初始化节点
Node *createNode(int data) {
    Node *node = (Node *) malloc(sizeof(Node));
    node->data = data;
    node->pre = NULL;
    node->next = NULL;
    return node;
}

//初始化链表
Node *createLinkList() {
    Node *list = (Node *) malloc(sizeof(Node));
    list->data = 0;
    list->pre = NULL;
    list->next = NULL;
    return list;
}

//头插法
void insertHead(LinKList *list, int data) {
    Node *newNode = createNode(data);
    //这里可以判断一下是否是第一次插入，因为第一次插入的时候仅仅只会操作来两个指针
    if (list->next == NULL) {
        //链表为空
        newNode->next = list->next;
        newNode->pre = list;
        list->next = newNode;
        list->data++;
    } else {
        //当链表不为空的时候
        newNode->pre = list;
        newNode->next = list->next;
        list->next->pre = newNode;
        list->next = newNode;
        list->data++;
    }
}

//尾插法
void initTail(LinKList *list, int data) {
    //创建一个newNode表示用于插入的节点
    Node *newNode = createNode(data);
    //创建一个pMoveNode节点用于遍历链表
    Node *pMoveNode = list;
    //当pMoveNode的next等于NULL时退出循环，此时pMoveNode就是链表的最后一个节点
    while (pMoveNode->next != NULL) {
        pMoveNode = pMoveNode->next;
    }
    //进行插入操作
    pMoveNode->next = newNode;
    newNode->pre = pMoveNode;
    newNode->next = NULL;
    list->data++;
}

//删除链表中的节点
int deleteNode(LinKList *list, int data) {
    Node *deleteNode = list->next;
    while (deleteNode != NULL) {
        if (deleteNode->data == data) {
            //表示找到对应的链表的节点,删除节点
            //同时这里还需要判断是否是最后一个节点
            if (deleteNode->next != NULL) {
                deleteNode->pre->next = deleteNode->next;
                deleteNode->next->pre = deleteNode->pre;
                free(deleteNode);
                list->data--;
            } else {
                deleteNode->pre->next=NULL;
                free(deleteNode);
                list->data--;
            }
            return TURE;
        }
        deleteNode = deleteNode->next;
    }
    return FALSE;
}

//打印链表
void printLinkList(LinKList *list) {
    //创建一个pMoveNode为第一节点，用于遍历所有节点
    Node *pMoveNode = list->next;
    //用于遍历循环，同时当pMoveNode等于NUUL时退出循环
    while (pMoveNode != NULL) {
        printf("(%d)->", pMoveNode->data);
        //用于遍历的核心条件
        pMoveNode = pMoveNode->next;
    }
    printf("NULL\n");
}

int main() {
    LinKList *list = createLinkList();
    printf("头插法\n");
    insertHead(list, 1);
    insertHead(list, 2);
    insertHead(list, 3);
    insertHead(list, 4);
    insertHead(list, 5);
    printLinkList(list);
    printf("尾插法\n");
    initTail(list, 6);
    initTail(list, 7);
    initTail(list, 8);
    initTail(list, 9);
    initTail(list, 10);
    printLinkList(list);
    printf("删除之后的链表");
    while (TURE){
        int num=0, deleteData=0;
        printf("输入0表示退出程序\n输入1表示执行删除操作\n输入2表示打印链表\n");
        scanf("%d",&num);
        switch (num) {
            //表示执行删除操作
            case 1:
                printf("请输入你想删除的节点的数据\n");
                scanf("%d",&deleteData);
                int lb=deleteNode(list,deleteData);
                if(lb==FALSE){
                    printf("该数据为（%d）的节点删除失败，请检查\n",deleteData);
                } else{
                    printf("已完成删除操作，请打印链表查看是否完成删除操作\n");
                }
                break;
            //表示执行打印操作
            case 2:
                printLinkList(list);
                break;
            //表示执行退出操作
            case 0:
                return 0;
                break;
        }
    }
}
```

运行结果：

```c
头插法
(5)->(4)->(3)->(2)->(1)->NULL
尾插法
(5)->(4)->(3)->(2)->(1)->(6)->(7)->(8)->(9)->(10)->NULL
删除之后的链表输入0表示退出程序
输入1表示执行删除操作
输入2表示打印链表
1
请输入你想删除的节点的数据
2
已完成删除操作，请打印链表查看是否完成删除操作
输入0表示退出程序
输入1表示执行删除操作
输入2表示打印链表
2
(5)->(4)->(3)->(1)->(6)->(7)->(8)->(9)->(10)->NULL
输入0表示退出程序
输入1表示执行删除操作
输入2表示打印链表
1
请输入你想删除的节点的数据
89
该数据为（89）的节点删除失败，请检查
输入0表示退出程序
输入1表示执行删除操作
输入2表示打印链表
2
(5)->(4)->(3)->(1)->(6)->(7)->(8)->(9)->(10)->NULL
输入0表示退出程序
输入1表示执行删除操作
输入2表示打印链表
0
```

### 双循环链表

其本质上与双链表的一致，不过是自己指向自己

c语言的简单实例：

```C
#include<stdio.h>
#include <stdlib.h>

#define Ture 1
#define False 0

/*
 * 双链表因为本身的特性原因，因而会有连个指针域
 * 其中pre指针是指向上一个节点的指针，next指向下一个节点的指针
 * 并且他跟单循环链表也很相似，所以本身也是自己指自己
 */

//创建节点
typedef struct Node {
	int data;
	struct Node *pre;
	struct Node *next;
} Node, LinKList;

//初始化节点
Node *createNode(int data) {
	Node *node = (Node *) malloc(sizeof(Node));
	node->data = data;
	node->pre = node;
	node->next = node;
	return node;
}

//初始化链表
Node *createLinkList() {
	Node *list = (Node *) malloc(sizeof(Node));
	list->data = 0;
	list->pre = list;
	list->next = list;
	return list;
}

//头插法
void insertHead(LinKList *list, int data) {
	Node *newNode = createNode(data);
	//这里可以判断一下是否是第一次插入，因为第一次插入的时候仅仅只会操作来两个指针
	if (list->next == list) {
		//链表指向头结点
		newNode->next = list->next;
		newNode->pre = list;
		list->next = newNode;
		list->data++;
	} else {
		//当链表不指向头结点
		newNode->pre = list;
		newNode->next = list->next;
		list->next->pre = newNode;
		list->next = newNode;
		list->data++;
	}
}

//尾插法
void initTail(LinKList *list, int data) {
	//创建一个newNode表示用于插入的节点
	Node *newNode = createNode(data);
	//创建一个pMoveNode节点用于遍历链表
	Node *pMoveNode = list;
	//当pMoveNode的next等于NULL时退出循环，此时pMoveNode就是链表的最后一个节点
	while (pMoveNode->next != list) {
		pMoveNode = pMoveNode->next;
	}
	//进行插入操作
	pMoveNode->next = newNode;
	newNode->pre = pMoveNode;
	newNode->next = list;
	list->data++;
}

//删除链表中的节点
int deleteNode(LinKList *list, int data) {
	Node *deleteNode = list->next;
	while (deleteNode != list) {
		if (deleteNode->data == data) {
			//表示找到对应的链表的节点,删除节点
			//同时这里还需要判断是否是最后一个节点
			if (deleteNode->next != list) {
				
				deleteNode->pre->next = deleteNode->next;
				deleteNode->next->pre = deleteNode->pre;
				free(deleteNode);
				list->data--;
			} else {
				
				deleteNode->pre->next = list;
				free(deleteNode);
				list->data--;
			}
			return Ture;
		}
		deleteNode = deleteNode->next;
	}
	return False;
}


//打印链表
void printLinkList(LinKList *list) {
	//创建一个pMoveNode为第一节点，用于遍历所有节点
	Node *pMoveNode = list->next;
	//用于遍历循环，同时当pMoveNode等于NUUL时退出循环
	while (pMoveNode != list) {
		printf("(%d)", pMoveNode->data);
		//用于遍历的核心条件
		if (pMoveNode->next != list) {
			printf("->");
		}
		pMoveNode = pMoveNode->next;
	}
	printf("\n");
}

int main() {
	LinKList *list = createLinkList();
	printf("头插法\n");
	insertHead(list, 1);
	insertHead(list, 2);
	insertHead(list, 3);
	insertHead(list, 4);
	insertHead(list, 5);
	printLinkList(list);
	printf("尾插法\n");
	initTail(list, 6);
	initTail(list, 7);
	initTail(list, 8);
	initTail(list, 9);
	initTail(list, 10);
	printLinkList(list);
	printf("删除之后的链表");
	while (Ture) {
		int num = 0, deleteData = 0;
		printf("输入0表示退出程序\n输入1表示执行删除操作\n输入2表示打印链表\n");
		scanf("%d", &num);
		switch (num) {
			//表示执行删除操作
		case 1:
			printf("请输入你想删除的节点的数据\n");
			scanf("%d", &deleteData);
			int lb = deleteNode(list, deleteData);
			if (lb == False) {
				printf("该数据为（%d）的节点删除失败，请检查\n", deleteData);
			} else {
				printf("已完成删除操作，请打印链表查看是否完成删除操作\n");
			}
			break;
			//表示执行打印操作
		case 2:
			printLinkList(list);
			break;
			//表示执行退出操作
		case 0:
			return 0;
		}
	}
}
```



## 第三章，栈和队列及递归

### 栈

凡是静态变量都是在栈里面的由操作系统进行分配，凡是通过动态内存分配的都是在堆里面的，需要手动进行分配。栈和堆本身是分配数据的一种方式。

定义：是一种可以实现“先进后出”的存储结构。

分类：静态栈（数组）、动态栈（链表）

栈的主要应用：

1. 函数调用
2. 中断
3. 表达式求值
4. 内存分配
5. 缓冲处理
6. 迷宫

#### 静态栈

静态栈的简单操作：

```c
#include <stdio.h>
#include <stdlib.h>

//结构体的初始化
typedef struct {
    int *base;
    int *top;
    int stacksize;
    int length;
} SqStack;

//栈的初始化
int initStack(SqStack *sqStack) {
    sqStack->stacksize = 10;
    //进行动态内存的赋值
    sqStack->base = (int *) malloc(sqStack->stacksize * sizeof(int));
    if (sqStack->base==NULL) {
        //如果初始化失败
        printf("初始化栈失败，请检查内存\n");
        return 0;
    }
    //剩余数据的初始化
    sqStack->top = sqStack->base;
    sqStack->length = 0;
    return 1;
}

//判断栈是否是空的，如果不是则返回栈顶的元素
int getTop(SqStack *sqStack, int *elem) {
    if (sqStack->base == sqStack->top) {
        //如果相等则表示栈是空的
        printf("此时的栈是空的\n");
        return 0;
    }
    //理论上来说这句等同于
    //*elem=*(sqStack->top-1);
    *elem = sqStack->base[sqStack->length - 1];
    return 1;
}

//在栈中插入元素
/*
  在顺序栈中插入元素的时候，同样要遵循顺序插入的原则，不能随机插入
 */
int insertSq(SqStack *sqStack, int elem) {
    //插入elem成为新的栈顶元素
    //判断栈是否已经写满了
    if (sqStack->length >= sqStack->stacksize) {
        //如果栈满了，进行自动扩容，通过动态内存的方式
        int newStacksize = sqStack->stacksize * 2;
        int *newBase;
        newBase = (int *) realloc(sqStack->base, newStacksize * sizeof(sqStack->base));
        if (!newBase) {
            //如果自动扩容失败
            printf("自动扩容失败，请检查内存");
            return 0;
        }
        //更新栈的数据
        sqStack->base = newBase;
        //这一步存疑？
        sqStack->top = sqStack->base + sqStack->stacksize;
        sqStack->stacksize = newStacksize;
    }
    /*
      开始执行插入操作，两种方法，一种通过指针一种通过数组
      按照我的习惯，我个人较倾向于通过数组，因为这样不容易出错
      指针操作为

     */
    sqStack->length++;
    sqStack->base[sqStack->length - 1] = elem;
    sqStack->top++;
    return 1;
}

//若栈不为空，删除栈顶元素并且返回
int pop(SqStack *sqStack, int *elem) {
    if (sqStack->base == sqStack->top) {
        //此时栈为空
        printf("此时栈为空，不能进行删除操作");
        return 0;
    }
    *elem = sqStack->base[sqStack->length - 1];
    sqStack->base[sqStack->length - 1] = 0;
    sqStack->top--;
    sqStack->length--;
    return 1;
}

//遍历
void print(SqStack *sqStack) {
    for (int i = 0; i < sqStack->length; i++) {
        printf("(%d)", sqStack->base[i]);
    }
    printf("\n");
}

int main() {
    SqStack sqStack;
    int elem;
    initStack(&sqStack);
    for (int i = 1; i <= 50; i++) {
        insertSq(&sqStack, i);
    }
    print(&sqStack);

    pop(&sqStack, &elem);
    printf("%d\n",elem);

    getTop(&sqStack,&elem);
    printf("%d\n",elem);
    return 0;
}
```

#### 动态栈

动态栈的简单实现

动态栈从本质上来说，还是链表，只不过此时的链表并不是用头结点去操作，而是通过两个指针一个指向头结点一个指向尾节点，并且只通过尾节点来操作链表，并且遍历也要从尾节点开始，所以这里的指针指的方向与链表当中是相反的。

```C
#include <stdio.h>
#include <stdlib.h>

//定义栈的节点
typedef struct Node
{
	int data;
	struct Node *next;
}Node;

//定义栈
typedef struct Stack{
	/*
	 * 一般情况下，Bottom不移动，一直指向栈底，
	 * 而Top一只移动，指向元素的上面一个节点
	 */
	//栈顶
	Node *Top;
	//栈底
	Node *Bottom;
}Stack,*Pstack;

//栈的初始化
void InitStack(Pstack stack){
	stack->Top=NULL;
	stack->Bottom=NULL;
	//这里有点像链表里面的初始化操作
	stack->Top=(Node *) malloc(sizeof(Node));
	if(stack->Top==NULL){
		printf("栈分配内存失败！\n");
		exit(-1);
	}
	//空栈是让他俩相等
	stack->Bottom=stack->Top;
	stack->Top->next=NULL;
}

//节点的初始化
Node *createNode(int data){
	Node *node=(Node *) malloc(sizeof(Node));
	if(node==NULL){
		printf("节点分配内存失败！\n");
		exit(-1);
	}
	node->data=data;
	node->next=NULL;
	return node;
}

//栈的写入操作
void push(Stack *stack,int data){
	//创建一个节点
	Node *newNode= createNode(data);
	//让新节点的指针域指向栈顶，这样就可以让原本最后一个节点与新节点连起来
	//然后再让栈顶指向新节点的地址
	//在栈中，栈底的指针一般保持不懂，只有栈顶的指针在移动
	newNode->next=stack->Top;
	stack->Top=newNode;
	return;
}

//遍历栈
void printStack(Stack *stack){
	Node *p=stack->Top;
	//判断栈是否为空
	if(stack->Bottom==stack->Top){
		printf("栈为空！\n");
		return;
	}
	//这里当p遍历到bottom所指向节点时退出循环
	//即链表的头结点，所以这里与链表遍历时推出的的循环条件还是不一样的
	while(p!=stack->Bottom){
		printf("(%d)",p->data);
		p=p->next;
		if(p!=stack->Bottom){
			printf("->");
		}
	}
	printf("\n");
	return;
}

//判断栈此时是否是空栈
int empty(Stack *stack){
	if(stack->Top==stack->Bottom){
		return 0;
	} else {
		return 1;
	}
}

//删除栈顶元素，并且返回所删除的元素
int pop(Stack *stack,int *data){
	//判断栈是否为空
	if(empty(stack)==0){
		printf("栈为空！\n");
		return 0;
	}
	Node *p=stack->Top;
	*data=p->data;
	stack->Top=p->next;
	free(p);
	return 1;
}

//清空真个栈中的有效数据，保留头结点
void clear(Stack *stack){
	//当链表为空的时候退出循环
	while(empty(stack)!=0){
		//删除栈顶元素，但是不返回
		Node *p=stack->Top;
		stack->Top=p->next;
		free(p);
	}
}

int main(){
	Stack stack;
	int a=0;
	InitStack(&stack);
	push(&stack,1);
	push(&stack,2);
	push(&stack,5);
	push(&stack,4);
	printStack(&stack);
	if(pop(&stack,&a)==1){
		printStack(&stack);
	}
	clear(&stack);
	printStack(&stack);
	return 0;
}
```

### 队列

定义：一种可以实现“先进先出”的数据结构 ，向队列中插入元素称为入队或进队，删除元素称为出队或离队

分类：

- 链式队列--用链表实现

- 静态队列--用数组实现，其中静态队列通常必须是循环队列


#### 链式队列

链式队列的简单实现：

```c
#include <stdio.h>
#include <stdlib.h>


//节点
typedef struct Node {
	int data;
	struct Node *next;
} Node;

//队列
typedef struct queue {
	Node *front;
	Node *rear;
} Queue;

//初始化队列
Queue *initQueue() {
	Queue *queue = (Queue *)malloc(sizeof(Queue));
	queue->front = NULL;
	queue->rear = NULL;
	return queue;
}

// 入队操作
void enqueue(Queue *queue, int data) {
	Node *newNode = (Node*)malloc(sizeof(Node));
	newNode->data = data;
	newNode->next = NULL;
	
	if (queue->rear == NULL) {
		queue->front = queue->rear = newNode;
	} else {
		queue->rear->next = newNode;
		queue->rear = newNode;
	}
}

int dequeue(Queue *queue) {
	if (queue->front == NULL) {
		printf("队列为空，出队失败\n");
		return 0;
	}
	int data = queue->front->data;
	Node *temp = queue->front;
	if (queue->front == queue->rear) {
		queue->front = queue->rear = NULL;
	} else {
		queue->front = queue->front->next;
	}
	free(temp);
	return data;
}

int isEmpty(Queue *queue) {
	if (queue->front == NULL) {
		return 1;
	} else {
		return 0;
	}
}

// 查看队列的大小
int size(Queue *queue) {
	int count = 0;
	// 创建一个指向Node结构体的指针
	Node *current = queue->front;
	
	// 遍历队列中的所有节点
	while (current != NULL) {
		// 计数器加1
		count++;
		// 将当前节点更新为当前节点的下一个节点
		current = current->next;
	}
	
	// 返回计数器的值
	return count;
}

//遍历队列数据
void print(Queue *queue){
	Node *pNode=queue->front;
	while(pNode!=NULL){
		printf("(%d)",pNode->data);
		pNode=pNode->next;
	}
	printf("\n");
}

int main() {
	
	// 创建一个队列
	Queue *queue = initQueue();
	
	// 入队操作
	enqueue(queue, 1);
	enqueue(queue, 2);
	enqueue(queue, 3);
	printf("当前队列内部的数据为:");
	print(queue);
	// 输出队列的大小
	printf("Size of queue: %d\n", size(queue));
	
	// 输出队列是否为空
	printf("Is queue empty: %d\n", isEmpty(queue));
	
	// 出队操作
	printf("Dequeued element: %d\n", dequeue(queue));
	
	// 输出队列的大小
	printf("Size of queue: %d\n", size(queue));
	
	// 出队操作
	printf("Dequeued element: %d\n", dequeue(queue));
	
	// 输出队列的大小
	printf("Size of queue: %d\n", size(queue));
	
	// 出队操作
	printf("Dequeued element: %d\n", dequeue(queue));
	
	// 输出队列的大小
	printf("Size of queue: %d\n", size(queue));
	
	// 输出队列是否为空
	printf("Is queue empty: %d\n", isEmpty(queue));
	
	// 释放队列
	free(queue);
	
	return 0;
}
```

运行结果：

```c
当前队列内部的数据为:(1)(2)(3)
Size of queue: 3
Is queue empty: 0
Dequeued element: 1
Size of queue: 2
Dequeued element: 2
Size of queue: 1
Dequeued element: 3
Size of queue: 0
Is queue empty: 1
```

#### 顺序队列

顺序队列的简单实现

```c++
#include <stdio.h>
#include <stdlib.h>

#define INITIAL_SIZE 5

typedef struct Queue {
	int *queueArray; // 存储队列元素的指针
	int front;       // 队列头部指针
	int rear;        // 队列尾部指针
	int size;        // 当前队列大小
	int capacity;    // 队列的容量
} Queue;

// 函数：初始化队列
void initializeQueue(Queue *q) {
	q->queueArray = (int *) malloc(INITIAL_SIZE * sizeof(int)); // 初始分配内存
	if (q->queueArray == NULL) {
		printf("内存分配失败，无法初始化队列。\n");
		exit(1);
	}
	q->front = -1;
	q->rear = -1;
	q->size = 0;
	q->capacity = INITIAL_SIZE;
}

// 函数：检查队列是否为空
bool isQueueEmpty(Queue *q) {
	if (q->front == -1) {
		return true;
	} else {
		return false;
	}
}

// 函数：入队操作
void enqueue(Queue *q, int item) {
	if (q->size == q->capacity) {
		// 队列已满，需要扩容
		int newCapacity = 2 * q->capacity;
		int *newQueue = (int *) realloc(q->queueArray, newCapacity * sizeof(int));
		if (newQueue == NULL) {
			printf("内存分配失败，无法扩容队列。\n");
			exit(1);
		}
		q->queueArray = newQueue;
		q->capacity = newCapacity;
	}
	
	if (isQueueEmpty(q)) {
		q->front = q->rear = 0;
	} else {
		q->rear++;
	}
	
	q->queueArray[q->rear] = item;
	q->size++;
	printf("入队：%d\n", item);
}

// 函数：出队操作
bool dequeue(Queue *q, int *item) {
	if (isQueueEmpty(q)) {
		printf("队列为空，无法出队。\n");
		return false;
	} else if (q->front == q->rear) {
		//即队列中只有一个元素的情况。
		//这是由于队列在出队时需要维护头部和尾部指针，
		//以确保它们正确地指向队列的前部和后部。
		/*
		  在这里，如果只有一个元素，那么q->front 和 q->rear都赋值成-1
		  此时，如果在进行入队操作，并不会进行自动扩容
		  而是直接覆写原本存在arr[0]里面的元素。
		  这样就不会造成数组的内存泄露。
		 */
		*item = q->queueArray[q->front];
		q->front = q->rear = -1;
	} else {
		*item = q->queueArray[q->front];
		q->front++;
	}
	q->size--;
	return true;
}

// 函数：查看队首元素
bool peek(Queue *q ,int *item) {
	if (isQueueEmpty(q)) {
		printf("队列为空，无法查看队首元素。\n");
		return false;
	}else {
		*item = q->queueArray[q->front];
		return true;
	}
}

// 函数：释放队列内存
void freeQueue(Queue *q) {
	free(q->queueArray);
}

int main() {
	// 初始化队列
	Queue myQueue;
	int item = 0;
	initializeQueue(&myQueue);
	
	// 测试入队操作
	enqueue(&myQueue, 10);
	enqueue(&myQueue, 20);
	enqueue(&myQueue, 30);
	enqueue(&myQueue, 40);
	enqueue(&myQueue, 50);
	
	// 查看队首元素
	if (peek(&myQueue, &item)) {
		printf("队首元素：%d\n", item);
	}
	
	// 测试出队操作
	if (dequeue(&myQueue, &item)) {
		printf("出队：%d\n", item);
	}
	if (dequeue(&myQueue, &item)) {
		printf("出队：%d\n", item);
	}
	if (dequeue(&myQueue, &item)) {
		printf("出队：%d\n", item);
	}
	if (dequeue(&myQueue, &item)) {
		printf("出队：%d\n", item);
	}
	if (dequeue(&myQueue, &item)) {
		printf("出队：%d\n", item);
	}
	// 查看队首元素
	if (peek(&myQueue, &item)) {
		printf("队首元素：%d\n", item);
	}
	enqueue(&myQueue, 10);
	enqueue(&myQueue, 20);
	enqueue(&myQueue, 30);
	enqueue(&myQueue, 40);
	if (peek(&myQueue, &item)) {
		printf("队首元素：%d\n", item);
	}
	// 释放队列内存
	freeQueue(&myQueue);
	return 0;
}

```

运行结果：

```c++
入队：10
入队：20
入队：30
入队：40
入队：50
队首元素：10
出队：10
出队：20
出队：30
出队：40
出队：50
队列为空，无法查看队首元素。
入队：10
入队：20
入队：30
入队：40
队首元素：10
```

#### 循环队列（数组）

简单说一下我对循环队列个人理解，就我个人而言，我感觉能想出来这个思想的人是真的nb。

在通过数组实现的循环队列当中的，并不是通过指针的实现，而是类似于索引的形式实现循环，在整个代码中，关于能够循环的语句我觉得是这两句话 `queue->front = (queue->front + 1) % MAX_SIZE;` 和 `queue->rear = (queue->rear + 1) % MAX_SIZE;` ，通过这两个语句完美的实现了数组的循环，通过这两个语句，我们可以发现当我们的`queue->front`等于`MAX_SIZE` 的时候，这一步操作能够实现让`queue->front`等于`0` ，同理`queue->rear = (queue->rear + 1) % MAX_SIZE;`这一步的实现同理。

在`printQueue()`函数当中的`int length=(queue->rear-queue->front+MAX_SIZE)%MAX_SIZE;`和`int index=queue->front;` 能够让正常的遍历数组，并且还是按照从`queue->front`到`queue->rear`的顺序。

最后需要谨记在这个循环队列当中，数组能存储的最大的元素个数是`MAX_SIZE-1`个。

循环队列（数组）的简单实现：

```c
#include <stdio.h>
#include <stdlib.h>
//设置最大值
#define MAX_SIZE 5
//创建结构体
typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

//初始化队列
Queue *initQueue() {
    Queue *queue = (Queue *) malloc(sizeof(Queue));
    queue->front = 0;
    queue->rear = 0;
    return queue;
}

//判断队列是否为满
//如果为满，则返回1，不满返回0
int isFull(Queue *queue) {
    if ((queue->rear + 1) % MAX_SIZE == queue->front) {
        return 1;
    } else {
        return 0;
    }
}

//判断队列是否为空
int isEmpty(Queue *queue) {
    if (queue->front == queue->rear) {
        //为空则返回1
        return 1;
    } else {
        //不为空则返回0
        return 0;
    }
}

//入队操作
int enQueue(Queue *queue, int data) {
    if (isFull(queue) == 1) {
        //若当前队列已满，则不进行入队操作
        return 0;
    } else {
        //执行入队操作
        queue->data[queue->rear] = data;
        queue->rear = (queue->rear + 1) % MAX_SIZE;
        return 1;
    }
}

//出队操作
int deQueue(Queue *queue) {
    if (isEmpty(queue) == 1) {
        //若当前队列为空，则不进行出队操作
        return -1;
    } else {
        //执行出队操作
        int data = queue->data[queue->front];
        queue->front = (queue->front + 1) % MAX_SIZE;
        return data;
    }
}

//遍历队列的操作
void printQueue(Queue *queue) {
    //要知道当前队列一共有多少个元素
    int length=(queue->rear-queue->front+MAX_SIZE)%MAX_SIZE;
    int index=queue->front;
    for (int i = 0; i < length; ++i) {
        printf("%d->",queue->data[index]);
        index=(index+1)%MAX_SIZE;
    }
    printf("NULL\n");
}

int main(){
    Queue *queue=initQueue();
    int data;
    enQueue(queue,1);
    enQueue(queue,4);
    enQueue(queue,5);
    enQueue(queue,2);
    enQueue(queue,3);
    printQueue(queue);
    printf("%d\n",deQueue(queue));
    printf("%d\n",deQueue(queue));
    printf("%d\n",deQueue(queue));
    printf("%d\n",deQueue(queue));
    printQueue(queue);
    enQueue(queue,3);
    enQueue(queue,11);
    enQueue(queue,12);
    printQueue(queue);
    printf("%d\n",deQueue(queue));
    printf("%d\n",deQueue(queue));
    printf("%d\n",deQueue(queue));
    printQueue(queue);
    return 0;
}
```

运行结果：

```c
1->4->5->2->NULL
1
4
5
2
NULL
3->11->12->NULL
3
11
12
NULL
```

### 递归

递归是一种常见的算法思想，它指的是在函数的定义中使用函数自身的方法。在数学和计算机领域中，递归主要包括递的过程和归的过程，即在运行的过程中不断地调用自己，但不能无限制地调用本身，须有个出口，化简为非递归状况处理。递归主要分为函数递归和递归算法，函数递归指的是某个函数自己调用自己，递归算法则是通过递归调用来解决问题。

通过递归来实现整数的阶乘：

```c
#include <stdio.h>

// 计算阶乘的递归函数
int factorial(int n) {
	// 如果n等于0，则返回1
	if (n == 0) {
		return 1;
	} else {
		// 否则，返回n乘以factorial(n - 1)的结果
		return n * factorial(n - 1);
	}
}

int main() {
	// 获取用户输入的整数
	int n;
	printf("请输入一个整数：");
	scanf("%d", &n);
	
	// 计算并打印输入整数的阶乘
	printf("%d的阶乘是：%d\n", n, factorial(n));
	
	// 返回0，表示程序执行成功
	return 0;
}
```

`这里很重要┗|｀O′|┛ 嗷~~，之后树就经常用到这里`

其实关于递归这里当进行递归调用时，系统会使用一个称为“函数调用栈”的数据结构来跟踪`每次函数调用的信息`。每个函数调用都会在栈中创建一个帧（frame），该帧包含了该函数的`局部变量、参数值`等信息。当函数调用结束时，它的帧会被弹出栈，控制权会返回到调用该函数的地方。这里就拿刚才写的计算阶乘的递归函数进行举例，这里可以根据van图来进行辅助理解

现在，如果你调用`factorial(5)`，它会在函数调用栈中创建以下帧：

1. `factorial(5)`：在栈底，计算`factorial(5 - 1)`，即`factorial(4)`。
2. `factorial(4)`：在上一个帧之上，计算`factorial(4 - 1)`，即`factorial(3)`。
3. `factorial(3)`：在上一个帧之上，计算`factorial(3 - 1)`，即`factorial(2)`。
4. `factorial(2)`：在上一个帧之上，计算`factorial(2 - 1)`，即`factorial(1)`。
5. `factorial(1)`：在上一个帧之上，计算`factorial(1 - 1)`，即`factorial(0)`。

现在，计算到`factorial(0)`，它返回1或者是停止递归的时候，并开始逐层返回到更高层的函数：

1. `factorial(1)` 返回 1 * 1 = 1。
2. `factorial(2)` 返回 2 * 1 = 2。
3. `factorial(3)` 返回 3 * 2 = 6。
4. `factorial(4)` 返回 4 * 6 = 24。
5. `factorial(5)` 返回 5 * 24 = 120。

这个过程是递归的核心：每个函数调用都等待其下级函数调用的结果，然后将它们合并在一起，最终返回给上级函数调用。这是递归的基本原理，适用于树遍历、阶乘计算等问题。

通过递归函数实现斐波那契数列：

```c
#include <stdio.h>

int fibonacci(int n) {
	// 如果n等于0或1，则返回n
	if (n == 0 || n == 1) {
		return n;
	} else {
		// 否则，返回fibonacci(n - 1) + fibonacci(n - 2)的结果
		return fibonacci(n - 1) + fibonacci(n - 2);
	}
}

int main() {
	// 获取用户输入的整数
	int n;
	printf("请输入一个整数：");
	scanf("%d", &n);
	
	// 计算并打印斐波那契数列的第n项
	printf("%d的斐波那契数列的第n项是：%d\n", n, fibonacci(n));
	
	// 返回0，表示程序执行成功
	return 0;
}
```

用递归实现1+2+3+...+100

```c
#include <stdio.h>

long sum(int n){
    if(n==1){
        return 1;
    } else{
        return sum(n-1)+n;
    }
}

int main(){
    int n=100;
    printf("%ld\n", sum(n));
    return 0;
}
```

用递归实现汉诺塔问题

```c
//用递归实现汉诺塔问题
#include<stdio.h>

void move(char A, char C, int n)
{
    printf("把第%d个圆盘从%c--->%c\n", n, A, C);
}

void HanoiTower(char A, char B, char C, int n)
{
    if (n == 1)
    {
        move(A, C, n);
    }
    else
    {
        //将n-1个圆盘从A柱借助于C柱移动到B柱上
        HanoiTower(A, C, B, n - 1);
        //将A柱子最后一个圆盘移动到C柱上
        move(A, C, n);
        //将n-1个圆盘从B柱借助于A柱移动到C柱上
        HanoiTower(B, A, C, n - 1);
    }
}

int main()
{
    int n = 0;
    printf("输入A柱子上的圆盘个数：");
    scanf("%d", &n);
    //将n个圆盘从A柱借助于B柱移动到C柱上
    HanoiTower('A', 'B', 'C', n);
    return 0;
}
```

## 第四章，树和图

### 树

#### 树的理论基础

树的定义：

- 专业定义：
  1. 有且只有一个称为根的节点
  2. 有若干个互不相交的子树，这些子树本身也是一棵树
- 通俗的定义：
  1. 树是由节点和边组成
  2. 每个节点只有一个父节点，但是可以有多个子节点
  3. 但是有一个节点例外，该节点没有父节点此节点，被称为根节点

一些专业术语：

- 节点		父节点		子节点
- 子孙		堂兄弟
- 深度：	从根节点到底层节点的层数称之为深度，根节点是第一层
- 叶节点：	没有子节点的节点
- 非终端节点：		实际上就是非叶子节点
- 度		子节点的个数称为度，度为0的节点就是叶子节点

树的分类：

- 一般的树
  - 任意一个节点的子节点个数都不受限制
- 二叉树
  - 任意一个节点的子节点的个数最多是两个，且子节点的位置不可更改
  - 分类：
    1. 一般二叉树
    2. 满二叉树
       - 在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树
    3. 完全二叉树
       - 如果只是删除了满二叉树最底层最右边的连续若干的节点，这样形成的树就是完全二叉树，就是从满二叉树删去几个节点并不影响原本节点的顺序（`注意了嗷这个很重要`）
    4. 平衡二叉树：
       - 树上任意节点的左子树和右子树的深度只差不超过1
- 森林
  - n个互不相交的树的集合

二叉树的常见性质：（`注意了嗷这个很重要`）

1. 在一个非空二叉树当中，度为0、1、2的节点分别称为n0、n1、n2，则n0=n2+1，即叶子节点的个数永远比有两个子节点的节点的个数多一个。

2. 二叉树的第i层，最多有`2ⁱ¯¹`个节点（i>1）
3. m差树第i层，最多有`m¹¯ⁱ`个节点（i>1）
4. 高度为i的二叉树最多有`2ⁱ-1`个节点（满二叉树）
5. 高度为i的n二叉树最多有`(nⁱ-1)/(n-1)`个节点

树的存储：

二叉树的存储

连续存储（通过数组实现，完全二叉树）

- 优点：在查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快

- 缺点：耗用内存空间很大


链式存储

- 缺点：浪费空间少
- 缺点：不容易找到父节点

树的基本操作：

- 遍历
  1. 先序遍历（`注意了嗷，只要有岔路口，就一路从左到底然后再依次访问右节点`）（`先访问根节点`）
     - 先访问根节点
     - 再先序访问左子树
     - 再先序访问右子树
  2. 中序遍历（`注意了嗷，这个跟先序遍历最大的不同就是，他不是从左到底`）（`中间访问根节点`）
     - 中序遍历左子树
     - 在访问根节点
     - 在中序遍历右节点
  3. 后序遍历（`最后访问根节点`）
     - 中序遍历左子树
     - 中序遍历右子树
     - 再访问根节点
- 已知两种遍历序列，求原始的二叉树
  - 只有通过先序和中序，或者是通过中序和后序，我们才可以唯一的确定一个二叉树

应用：

树是数据库当中数据组织一种重要的形式

操作系统父子进程的关系本身就是一棵树

面向对象语言中类的继承关系

#### 查找二叉树

查找二叉树的基本操作

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点的结构体
struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};

// 创建一个新的二叉树节点
struct TreeNode *createNode(int data) {
    struct TreeNode *newNode = (struct TreeNode *) malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 插入一个新的二叉树节点到二叉树中
struct TreeNode *insertNode(struct TreeNode *root, int data) {
    // 如果当前节点为空（子树为空），创建一个新节点并返回
    if (root == NULL) {
        return createNode(data);
    } else {
        // 否则，根据插入节点的值与当前节点的值比较
        if (data < root->data) {
            // 如果插入节点的值小于当前节点的值，将节点插入到当前节点的左子树中
            root->left = insertNode(root->left, data);
        } else {
            // 如果插入节点的值大于等于当前节点的值，将节点插入到当前节点的右子树中
            root->right = insertNode(root->right, data);
        }
    }
    // 返回更新后的树的根节点
    return root;
}

// 查找二叉树中的一个节点
// 参数:
// - root: 二叉树的根节点
// - data: 要查找的数据值
// 返回值:
// - 如果找到了包含数据值的节点，返回该节点的指针
// - 如果未找到，返回 NULL
struct TreeNode *searchNode(struct TreeNode *root, int data) {
    // 如果当前节点为NULL，表示二叉树为空或已经搜索到了叶子节点，未找到匹配的数据值
    if (root == NULL) {
        return NULL;
    }

    // 如果当前节点的数据值与要查找的数据值相等，表示找到了匹配的节点，返回该节点的指针
    if (root->data == data) {
        return root;
    }

    // 如果要查找的数据值小于当前节点的数据值，向左子树递归查找
    // 注意：在二叉搜索树中，左子树的所有节点的值都小于当前节点的值
    if (data < root->data) {
        return searchNode(root->left, data);
    }
        // 如果要查找的数据值大于当前节点的数据值，向右子树递归查找
        // 注意：在二叉搜索树中，右子树的所有节点的值都大于当前节点的值
    else {
        return searchNode(root->right, data);
    }
}

// 查找二叉树中的最小节点
struct TreeNode *findMin(struct TreeNode *root) {
    // 如果传入的根节点为空，说明树为空，直接返回 NULL
    if (root == NULL) {
        return NULL;
    }
    // 从传入的根节点开始，一直沿着左子树往下遍历，直到找到没有左子树的节点
    // 这个过程保证了在二叉搜索树中，最小的节点一定是在最左侧的分支上
    while (root->left != NULL) {
        root = root->left;
    }
    // 返回最小节点，它是找到的最左侧的叶子节点
    return root;
}


// 删除二叉树中的一个节点
struct TreeNode *deleteNode(struct TreeNode *root, int data) {
    if (root == NULL) {
        // 如果根节点为空，返回根节点为空，表示没有找到要删除的数据
        return root;
    } else if (data < root->data) {
        // 如果要删除的数据比当前节点的数据小，递归地在左子树中查找并删除
        root->left = deleteNode(root->left, data);
    } else if (data > root->data) {
        // 如果要删除的数据比当前节点的数据大，递归地在右子树中查找并删除
        root->right = deleteNode(root->right, data);
    } else if(root->data==data){
        // 找到了要删除的节点

        if (root->left == NULL && root->right == NULL) {
            // 情况1：要删除的节点没有子节点（叶子节点）
            free(root); // 释放内存
            root = NULL; // 将当前节点设为NULL，表示已删除
        } else if (root->left == NULL) {
            // 情况2：要删除的节点只有右子树
            struct TreeNode *temp = root; // 保存当前节点的指针
            root = root->right; // 将当前节点替换为右子树
            free(temp); // 释放原节点的内存
        } else if (root->right == NULL) {
            // 情况3：要删除的节点只有左子树
            struct TreeNode *temp = root; // 保存当前节点的指针
            root = root->left; // 将当前节点替换为左子树
            free(temp); // 释放原节点的内存
        } else {
            // 情况4：要删除的节点既有左子树又有右子树
            // 找到右子树中的最小值节点，将其值复制到当前节点，然后删除右子树中的最小值节点
            /*
             * 简单解释一下为什么要这样做，因为这里的这个是一个平衡二叉树，什么意思呢？
             * 就是说我的左子节点一定比我的右节点要小，此时我找到右子树当中最小的节点就一定比左子树所有节点都大
             * 同时也会比根节点大，为什么？因为比根节点小的都存到左子树里面了
             * 那么此时我要删除根节点就要找到右子树里面最小的节点放到根节点的位置
             */
            struct TreeNode *temp = findMin(root->right); // 找到右子树中的最小值节点
            root->data = temp->data; // 将当前节点的值替换为最小值节点的值
            root->right = deleteNode(root->right, temp->data); // 递归地删除右子树中的最小值节点
        }
    }
    return root;
}


/*
 * 众所周知，每一次递归，系统都会使用一个叫函数调用栈的数据结构来跟踪每次函数调用的信息
 * 每个函数调用都会在栈中创建一个帧（frame），该帧包含了该函数的局部变量、参数值等信息。
 * 当函数调用结束时，它的帧会被弹出栈，控制权会返回到调用该函数的地方。
 * 这就能够很容易解释为什么在遍历到NULL的时候还能够返回上一级
 * 如果还有不明白的地方，详细请看我写的笔记有关递归方面的笔记
 */
/**
 * 前序遍历二叉树并打印节点数据
 *
 * @param root 二叉树的根节点
 *
 * 该函数用于前序遍历二叉树，从根节点开始，首先访问根节点，然后递归地访问左子树，最后递归地访问右子树。
 * 在遍历的过程中，它会打印每个节点的数据值。
 */
void printPreOrder(struct TreeNode *root) {
    // 如果根节点为空，表示空树或者递归到了叶子节点的空子树，返回并结束递归。
    if (root == NULL) {
        return;
    }

    // 打印当前节点的数据值，表示前序遍历的访问顺序。
    printf("%d ", root->data);

    // 递归遍历左子树，继续前序遍历左子树的节点。
    printPreOrder(root->left);

    // 递归遍历右子树，继续前序遍历右子树的节点。
    printPreOrder(root->right);
}

/**
 * 中序遍历二叉树并打印节点数据
 *
 * @param root 二叉树的根节点
 *
 * 该函数用于中序遍历二叉树，从根节点开始，先递归地遍历左子树，然后访问根节点，最后递归地遍历右子树。
 * 在遍历的过程中，它会打印每个节点的数据值。
 * 当然我们遍历之后发现只有中序遍历是从小到大遍历的
 */
void printInOrder(struct TreeNode *root) {
    // 如果根节点为空，表示空树或者递归到了叶子节点的空子树，返回并结束递归。
    if (root == NULL) {
        return;
    }

    // 递归遍历左子树，继续中序遍历左子树的节点。
    printInOrder(root->left);

    // 打印当前节点的数据值，表示中序遍历的访问顺序。
    printf("%d ", root->data);

    // 递归遍历右子树，继续中序遍历右子树的节点。
    printInOrder(root->right);
}

/**
 * 后序遍历二叉树并打印节点数据
 *
 * @param root 二叉树的根节点
 *
 * 该函数用于后序遍历二叉树，从根节点开始，先递归地遍历左子树，然后递归地遍历右子树，最后访问根节点。
 * 在遍历的过程中，它会打印每个节点的数据值。
 */
void printPostOrder(struct TreeNode *root) {
    // 如果根节点为空，表示空树或者递归到了叶子节点的空子树，返回并结束递归。
    if (root == NULL) {
        return;
    }

    // 递归遍历左子树，继续后序遍历左子树的节点。
    printPostOrder(root->left);

    // 递归遍历右子树，继续后序遍历右子树的节点。
    printPostOrder(root->right);

    // 打印当前节点的数据值，表示后序遍历的访问顺序。
    printf("%d ", root->data);
}

int main() {
    struct TreeNode *root = NULL;
    root = insertNode(root, 10);
    root = insertNode(root, 5);
    root = insertNode(root, 15);
    root = insertNode(root, 3);
    root = insertNode(root, 7);
    root = insertNode(root, 12);
    root = insertNode(root, 17);
    root = insertNode(root, 11);
    root = insertNode(root, 13);
    root = insertNode(root, 16);
    root = insertNode(root, 20);
    printf("二叉树的前序遍历： ");
    printPreOrder(root);
    printf("\n");
    printf("二叉树的中序遍历： ");
    printInOrder(root);
    printf("\n");
    printf("二叉树的后序遍历： ");
    printPostOrder(root);
    printf("\n");
    struct TreeNode *node = searchNode(root, 12);
    if (node != NULL) {
        printf("找到了包含数据的节点 %d\n", node->data);
    } else {
        printf("未找到节点\n");
    }
    root = deleteNode(root, 15);
    printf("删除 15 后二叉树的前序遍历： ");
    printPreOrder(root);
    printf("\n");
    printf("删除 15 后二叉树的中序遍历： ");
    printInOrder(root);
    printf("\n");
    printf("删除 15 后二叉树的后序遍历： ");
    printPostOrder(root);
    printf("\n");
    return 0;
}
```

运行结果

```c
二叉树的前序遍历： 10 5 3 7 15 12 11 13 17 16 20
二叉树的中序遍历： 3 5 7 10 11 12 13 15 16 17 20
二叉树的后序遍历： 3 7 5 11 13 12 16 20 17 15 10
找到了包含数据的节点 12
删除 15 后二叉树的前序遍历： 10 5 3 7 16 12 11 13 17 20
删除 15 后二叉树的中序遍历： 3 5 7 10 11 12 13 16 17 20
删除 15 后二叉树的后序遍历： 3 7 5 11 13 12 20 17 16 10
```

